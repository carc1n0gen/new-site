1:HL["/_next/static/css/4c3ba0c712eb50f7.css",{"as":"style"}]
0:["HVOfH4A8LqJ-k-QTXKGTD",[[["",{"children":[["year","2020","d"],{"children":[["month","07","d"],{"children":[["day","06","d"],{"children":[["slug","request-method-spoofing-in-flask","d"],{"children":["__PAGE__?{\"year\":\"2020\",\"month\":\"07\",\"day\":\"06\",\"slug\":\"request-method-spoofing-in-flask\"}",{}]}]}]}]}]},"$undefined","$undefined",true],"$L2",[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/4c3ba0c712eb50f7.css","precedence":"next"}]],["$L3",null]]]]]
4:I{"id":7095,"chunks":["95:static/chunks/95-b42e21927908bec6.js","224:static/chunks/224-45995354792692c9.js","106:static/chunks/app/[year]/[month]/[day]/[slug]/page-fd3e7a5daa90e646.js"],"name":"","async":false}
5:I{"id":7289,"chunks":["95:static/chunks/95-b42e21927908bec6.js","185:static/chunks/app/layout-3babe0f43a2270ad.js"],"name":"","async":false}
6:I{"id":9180,"chunks":["272:static/chunks/webpack-a2ef0b461975a909.js","253:static/chunks/bce60fc1-3d7875a7a6202410.js","698:static/chunks/698-4595f783858dddc6.js"],"name":"default","async":false}
7:I{"id":2306,"chunks":["272:static/chunks/webpack-a2ef0b461975a909.js","253:static/chunks/bce60fc1-3d7875a7a6202410.js","698:static/chunks/698-4595f783858dddc6.js"],"name":"default","async":false}
2:[["$","html",null,{"lang":"en","className":"dark:bg-black md:bg-zinc-50 md:dark:bg-zinc-800","children":["$","body",null,{"className":"text-zinc-700 dark:text-zinc-300","children":[["$","header",null,{"className":"bg-white dark:bg-black text-center md:text-left mt-5 md:mt-0 md:pt-10 border-b border-b-zinc-300 dark:border-b-zinc-600","children":[["$","div",null,{"className":"md:max-w-screen-md px-2 md:px-0 mx-auto","children":[["$","img",null,{"src":"/img/avatar-new.jpg","alt":"Avatar photo","className":"rounded-full mx-auto md:float-right md:-mt-4","width":"100","height":"100"}],["$","div",null,{"className":"mt-5","children":[["$","$L4",null,{"href":"/","className":"mt-2","children":["$","h1",null,{"className":"text-5xl font-bold","children":"Carson's Blog"}]}],["$","p",null,{"className":"mt-2","children":"Somewhat coherent tutorials about web stuff and things."}]]}]]}],["$","$L5",null,{}]]}],["$","main",null,{"className":"px-4 py-2 md:p-0 md:max-w-screen-md mx-auto","children":["$","$L6",null,{"parallelRouterKey":"children","segmentPath":["children"],"error":"$undefined","errorStyles":"$undefined","loading":"$undefined","loadingStyles":"$undefined","hasLoading":false,"template":["$","$L7",null,{}],"templateStyles":"$undefined","notFound":["$","section",null,{"className":"mt-6 p-6 bg-white border border-zinc-300","children":[["$","h1",null,{"className":"font-bold text-3xl mb-4","children":"Not Found"}],["$","p",null,{"children":"Are you lost? There doesn't seem to be anything here"}]]}],"notFoundStyles":[],"childProp":{"current":["$","$L6",null,{"parallelRouterKey":"children","segmentPath":["children",["year","2020","d"],"children"],"error":"$undefined","errorStyles":"$undefined","loading":"$undefined","loadingStyles":"$undefined","hasLoading":false,"template":["$","$L7",null,{}],"templateStyles":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","childProp":{"current":["$","$L6",null,{"parallelRouterKey":"children","segmentPath":["children",["year","2020","d"],"children",["month","07","d"],"children"],"error":"$undefined","errorStyles":"$undefined","loading":"$undefined","loadingStyles":"$undefined","hasLoading":false,"template":["$","$L7",null,{}],"templateStyles":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","childProp":{"current":["$","$L6",null,{"parallelRouterKey":"children","segmentPath":["children",["year","2020","d"],"children",["month","07","d"],"children",["day","06","d"],"children"],"error":"$undefined","errorStyles":"$undefined","loading":"$undefined","loadingStyles":"$undefined","hasLoading":false,"template":["$","$L7",null,{}],"templateStyles":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","childProp":{"current":["$","$L6",null,{"parallelRouterKey":"children","segmentPath":["children",["year","2020","d"],"children",["month","07","d"],"children",["day","06","d"],"children",["slug","request-method-spoofing-in-flask","d"],"children"],"error":"$undefined","errorStyles":"$undefined","loading":"$undefined","loadingStyles":"$undefined","hasLoading":false,"template":["$","$L7",null,{}],"templateStyles":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","childProp":{"current":["$L8",null],"segment":"__PAGE__?{\"year\":\"2020\",\"month\":\"07\",\"day\":\"06\",\"slug\":\"request-method-spoofing-in-flask\"}"},"styles":[]}],"segment":["slug","request-method-spoofing-in-flask","d"]},"styles":[]}],"segment":["day","06","d"]},"styles":[]}],"segment":["month","07","d"]},"styles":[]}],"segment":["year","2020","d"]},"styles":[]}]}],["$","footer",null,{"className":"mt-6 mb-4 text-center","children":"© Carson Evans"}]]}]}],null]
3:[["$","meta","0",{"charSet":"utf-8"}],["$","title","1",{"children":"Request Method Spoofing in Flask - Carson's Blog"}],["$","meta","2",{"name":"description","content":"I recently found myself wanting to do method spoofing in flask. It turned out this isn't such a simple straight forward thing to do. So sit back while I take you down the rabbit hole that is method spoofing in flask."}],["$","meta","3",{"name":"keywords","content":"flask request method spoofing adventure"}],["$","meta","4",{"name":"viewport","content":"width=device-width, initial-scale=1"}],["$","link","5",{"rel":"icon","href":"/favicon.ico","type":"image/x-icon","sizes":"any"}]]
c:I{"id":4368,"chunks":["95:static/chunks/95-b42e21927908bec6.js","224:static/chunks/224-45995354792692c9.js","106:static/chunks/app/[year]/[month]/[day]/[slug]/page-fd3e7a5daa90e646.js"],"name":"","async":false}
9:T5b1,<span class="hljs-keyword">class</span> <span class="hljs-title class_">MethodSpooferMiddleware</span>():
  	<span class="hljs-string">&quot;&quot;&quot;
    A WSGI middleware that checks for a method spoofing form field
    and overrides the request method accordingly.
    &quot;&quot;&quot;</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, app</span>):
        self.app = app

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__call__</span>(<span class="hljs-params">self, environ, start_response</span>):
      	<span class="hljs-comment"># We only want to spoof if the request method is POST</span>
        <span class="hljs-keyword">if</span> environ[<span class="hljs-string">&#x27;REQUEST_METHOD&#x27;</span>].upper() == <span class="hljs-string">&#x27;POST&#x27;</span>:
            request = Request(environ)
            method = request.form.get(<span class="hljs-string">&#x27;_method&#x27;</span>)
            <span class="hljs-keyword">if</span> method:
              	<span class="hljs-comment"># override the request method if there was a method spoofing form field.</span>
                environ[<span class="hljs-string">&#x27;REQUEST_METHOD&#x27;</span>] = method

        <span class="hljs-keyword">return</span> self.app(environ, start_response)


app = Flask(__name__)
app.wsgi_app = MethodSpooferMiddleware(app.wsgi_app)a:T6ba,<span class="hljs-keyword">from</span> werkzeug.formparser <span class="hljs-keyword">import</span> parse_form_data
<span class="hljs-keyword">from</span> werkzeug.wsgi <span class="hljs-keyword">import</span> get_input_stream
<span class="hljs-keyword">from</span> io <span class="hljs-keyword">import</span> BytesIO

<span class="hljs-keyword">class</span> <span class="hljs-title class_">MethodSpooferMiddleware</span>():
    <span class="hljs-string">&quot;&quot;&quot;Don&#x27;t actually do this. The disadvantages are not worth it.&quot;&quot;&quot;</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, app</span>):
        self.app = app

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__call__</span>(<span class="hljs-params">self, environ, start_response</span>):
        <span class="hljs-keyword">if</span> environ[<span class="hljs-string">&#x27;REQUEST_METHOD&#x27;</span>].upper() == <span class="hljs-string">&#x27;POST&#x27;</span>:
            environ[<span class="hljs-string">&#x27;wsgi.input&#x27;</span>] = stream = \
                BytesIO(get_input_stream(environ).read())
            form = parse_form_data(environ)[<span class="hljs-number">1</span>]
            stream.seek(<span class="hljs-number">0</span>)

            method = form.get(<span class="hljs-string">&#x27;_method&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>).upper()
            <span class="hljs-keyword">if</span> method:
                environ[<span class="hljs-string">&#x27;REQUEST_METHOD&#x27;</span>] = method

        <span class="hljs-keyword">return</span> self.app(environ, start_response)b:T1313,<span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Request


<span class="hljs-keyword">class</span> <span class="hljs-title class_">InputProcessed</span>():
    <span class="hljs-string">&quot;&quot;&quot;A file like object that just raises an error when it is read.&quot;&quot;&quot;</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">read</span>(<span class="hljs-params">self, *args</span>):
        <span class="hljs-keyword">raise</span> EOFError(
            <span class="hljs-string">&#x27;The wsgi.input stream has already been consumed, check environ[&quot;wsgi._post_form&quot;] \
             and environ[&quot;wsgi._post_files&quot;] for previously processed form data.&#x27;</span>
        )
    readline = readlines = __iter__ = read


<span class="hljs-keyword">class</span> <span class="hljs-title class_">MethodSpooferMiddleware</span>():
    <span class="hljs-string">&quot;&quot;&quot;
    A WSGI middleware that checks for a method spoofing form field
    and overrides the request method accordingly.
    &quot;&quot;&quot;</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, app, input_name=<span class="hljs-string">&#x27;_method&#x27;</span></span>):
        self.app = app
        self.input_name = input_name

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__call__</span>(<span class="hljs-params">self, environ, start_response</span>):
        <span class="hljs-comment"># We only want to spoof if the request method is POST</span>
        <span class="hljs-keyword">if</span> environ[<span class="hljs-string">&#x27;REQUEST_METHOD&#x27;</span>].upper() == <span class="hljs-string">&#x27;POST&#x27;</span>:
            stream, form, files = parse_form_data(environ)

            <span class="hljs-comment"># Replace the wsgi.input stream with an object that will raise an error if</span>
            <span class="hljs-comment"># it is read again, and explaining how to get previously processed form data.</span>
            environ[<span class="hljs-string">&#x27;wsgi.input&#x27;</span>] = InputProcessed()

            <span class="hljs-comment"># Set the processed form data on environ so it can be retrieved again inside</span>
            <span class="hljs-comment"># the app without having to process the form data again.</span>
            environ[<span class="hljs-string">&#x27;wsgi._post_form&#x27;</span>] = form
            environ[<span class="hljs-string">&#x27;wsgi._post_files&#x27;</span>] = files

            method = form.get(self.input_name)
            <span class="hljs-keyword">if</span> method:
                <span class="hljs-comment"># Override the request method _if_ there was a method spoofing field.</span>
                environ[<span class="hljs-string">&#x27;REQUEST_METHOD&#x27;</span>] = method
        <span class="hljs-keyword">return</span> self.app(environ, start_response)


<span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomRequest</span>(<span class="hljs-title class_ inherited__">Request</span>):
    <span class="hljs-string">&quot;&quot;&quot;
    A custom request object that checks for previously processed form data
    instead of possibly processing form data twice.
    &quot;&quot;&quot;</span>

<span class="hljs-meta">    @property</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">form</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;wsgi._post_form&#x27;</span> <span class="hljs-keyword">in</span> self.environ:
            <span class="hljs-comment"># If cached form data exists.</span>
            <span class="hljs-keyword">return</span> self.environ[<span class="hljs-string">&#x27;wsgi._post_form&#x27;</span>]
        <span class="hljs-comment"># Otherwise return the normal dict like object you would usually use.</span>
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>().form

<span class="hljs-meta">    @property</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">files</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;wsgi._post_files&#x27;</span> <span class="hljs-keyword">in</span> self.environ:
            <span class="hljs-comment"># If cached files data exists.</span>
            <span class="hljs-keyword">return</span> self.environ[<span class="hljs-string">&#x27;wsgi._post_files&#x27;</span>]
        <span class="hljs-comment"># Otherwise return the normal dict like object you would usually use.</span>
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>().files8:["$","article",null,{"className":"mt-6 md:p-6 bg-white dark:bg-black md:border border-zinc-300 dark:border-zinc-600","children":[["$","header",null,{"children":[["$","$L4",null,{"href":"/2020/07/06/request-method-spoofing-in-flask","children":["$","h2",null,{"className":"text-3xl font-bold mb-2","children":"Request Method Spoofing in Flask"}]}],["$","p",null,{"className":"mb-4 text-sm text-zinc-500","children":["posted by ","Carson Evans"," ·"," ","Jul 6, 2020"]}]]}],["$","section",null,{"children":["I recently found myself wanting to do method spoofing in flask. It turned out this isn't such a simple straight forward thing to do. So sit back while I take you down the rabbit hole that is method spoofing in flask.","\n",["$","h2",null,{"className":"text-2xl font-bold mt-6 mb-2","children":"What Is Method Spoofing?"}],"\n",["$","p",null,{"className":"my-4","children":"Browsers can only submit GET or POST requests. So if you want the route in the backend to respond to DELETE requests, a common workaround is to \"spoof\" the method using a hidden input on a POST form."}],"\n",["$","pre",null,{"className":"my-4 -mx-4 md:-mx-[25px]","children":["$","code",null,{"className":"hljs","dangerouslySetInnerHTML":{"__html":"<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">form</span> <span class=\"hljs-attr\">method</span>=<span class=\"hljs-string\">&quot;POST&quot;</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;hidden&quot;</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;_method&quot;</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&quot;DELETE&quot;</span> /&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;submit&quot;</span>&gt;</span>Submit<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">form</span>&gt;</span>"}}]}],"\n",["$","p",null,{"className":"my-4","children":"Then on the backend, you would do some sort of processing of the form in a middleware or something that checks for the existence of this field, and sets the request method accordingly. But again, this isn't such a simple task in flask."}],"\n",["$","h2",null,{"className":"text-2xl font-bold mt-6 mb-2","children":"The Naive Solution"}],"\n",["$","p",null,{"className":"my-4","children":["Originally I figured I could use a before_request hook to check if a ",["$","code",null,{"className":"font-bold","children":"_method"}]," key existed in ",["$","code",null,{"className":"font-bold","children":"request.form"}],"."]}],"\n",["$","pre",null,{"className":"my-4 -mx-4 md:-mx-[25px]","children":["$","code",null,{"className":"hljs","dangerouslySetInnerHTML":{"__html":"<span class=\"hljs-keyword\">from</span> flask <span class=\"hljs-keyword\">import</span> request\n\n<span class=\"hljs-meta\">@app.before_request</span>\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">before_request</span>():\n    method = request.form.get(<span class=\"hljs-string\">&#x27;_method&#x27;</span>)\n        <span class=\"hljs-keyword\">if</span> method:\n            <span class=\"hljs-comment\"># override the request method if there was a method spoofing form field.</span>\n            request.method = method"}}]}],"\n",["$","p",null,{"className":"my-4","children":"But I was quickly given a error explaining that the request object was read only. So It was clear I was going to have to do this in a wsgi middleware, which executes before the flask app code. This also turned out to be not so simple. This is my original naive solution."}],"\n",["$","pre",null,{"className":"my-4 -mx-4 md:-mx-[25px]","children":["$","code",null,{"className":"hljs","dangerouslySetInnerHTML":{"__html":"$9"}}]}],"\n",["$","p",null,{"className":"my-4","children":["This worked great at first. This correctly made a submitted POST form invoke a route set to respond to a DELETE request in the flask app. There is a problem that arises when you try to access form data in the flask app though. When we did ",["$","code",null,{"className":"font-bold","children":"request = Request(environ)"}],", we actually consumed the whole ",["$","code",null,{"className":"font-bold","children":"wsgi.input"}]," stream. This is the raw request body data that wsgi applications parse to get the submitted data. The problem is that this stream can only be read once. So I did a little googling, and it turned out I was not to first to go down this rabbit hole, and also hit this problem."]}],"\n",["$","h2",null,{"className":"text-2xl font-bold mt-6 mb-2","children":"A Not So Great Workaround"}],"\n",["$","p",null,{"className":"my-4","children":["I found ",["$","a",null,{"href":"https://stackoverflow.com/a/17828333","className":"font-bold underline","children":"a stackoverflow question"}]," from someone who had run in to the exact same problem as me. There was a \"workaround\" in the accepted answer where you would consume the ",["$","code",null,{"className":"font-bold","children":"wsgi.input"}]," stream in to a BytesIO stream, and then replace ",["$","code",null,{"className":"font-bold","children":"wsgi.input"}]," with this new stream. The reason is that a BytesIO stream can seek back to the beginning when you reach the end, where as the original stream could not. So we simply call ",["$","code",null,{"className":"font-bold","children":"stream.seek(0)"}]," once we have parsed the form data, so that it can be read again."]}],"\n",["$","pre",null,{"className":"my-4 -mx-4 md:-mx-[25px]","children":["$","code",null,{"className":"hljs","dangerouslySetInnerHTML":{"__html":"$a"}}]}],"\n",["$","p",null,{"className":"my-4","children":["This actually works, and if I hadn't of looked close enough at the snippet, I would have stopped here and called it a working solution. But then I noticed the docstring ",["$","code",null,{"className":"font-bold","children":"\"\"\"Don't actually do this. The disadvantages are not worth it.\"\"\""}],", so I took another look at stackoverflow answer. The problem with this workaround is that you end up processing the form twice. Once inside the middleware where the spoofing happens, and again in your flask app. The workaround was just hiding the problem. Resetting the stream back to its start is ",["$","em",null,{"children":"not"}]," a good solution if it means processing the data twice. What we really need to do is parse the form, and cache it somewhere the flask app can access instead of trying to parse the form twice."]}],"\n",["$","h2",null,{"className":"text-2xl font-bold mt-6 mb-2","children":"Override All The Things"}],"\n",["$","p",null,{"className":"my-4","children":["So I sort of came up with a hybrid solution. I parsed the form data, and then stored the parsed form data on the wsgi environ, where the flask app can access it later. I then created a custom Request class that checks if this previously parsed form data exists, and uses it if it does. This way, we don't have the problem with ",["$","code",null,{"className":"font-bold","children":"wsgi.input"}]," stream already being consumed, and we don't parse the form data twice either. I also created a file like object class that I replace the ",["$","code",null,{"className":"font-bold","children":"wsgi.input"}]," stream with after parsing the form data. This so if you do try to read from it again, there will be an error raised that explains the data has already been consumed, and to check ",["$","code",null,{"className":"font-bold","children":"wsgi._post_form"}]," and ",["$","code",null,{"className":"font-bold","children":"wsgi._post_files"}]," for the parsed form data instead."]}],"\n",["$","p",null,{"className":"my-4","children":"So first things first, here is the final WSGI middleware, and the custom Request class. Hopefully the comments do a good job of explaining what everything does."}],"\n",["$","pre",null,{"className":"my-4 -mx-4 md:-mx-[25px]","children":["$","code",null,{"className":"hljs","dangerouslySetInnerHTML":{"__html":"$b"}}]}],"\n",["$","p",null,{"className":"my-4","children":"Finally, here is a snippet showing how to use this middleware and the custom request class in a flask app."}],"\n",["$","pre",null,{"className":"my-4 -mx-4 md:-mx-[25px]","children":["$","code",null,{"className":"hljs","dangerouslySetInnerHTML":{"__html":"app = Flask(__name__)\napp.request_class = CustomRequest\napp.wsgi_app = MethodSpooferMiddleware(app.wsgi_app)"}}]}],"\n",["$","p",null,{"className":"my-4","children":["Now I just want to make the disclaimer that after ",["$","em",null,{"children":"all"}]," of this work, I don't think I'm going to be doing method spoofing in my app. This solution works very well, but it still feels like a hack. I think I'll stick to having to use POST for all operations when using html forms. But if you are okay with all of this added code, then have at it. Don't let me tell you what to do. It's going to come down to ones own feelings/opinions."]}],"\n",["$","p",null,{"className":"my-4","children":["Something else I should raise is that if your app also uses ",["$","code",null,{"className":"font-bold","children":"request.json"}]," to get json data from requests, you're going to want to skip doing any of the spoofing at all. Don't consume the ",["$","code",null,{"className":"font-bold","children":"wsgi.input"}]," stream, and just leave everything as it was. I'll leave that as an exercise for the reader (Hint: will need to check if the content type is ",["$","code",null,{"className":"font-bold","children":"application/json"}],")."]}],"\n",["$","p",null,{"className":"my-4","children":["If you would like to reference a complete working flask app that ties all of this together, I have one right ",["$","a",null,{"href":"https://github.com/carc1n0gen/tutorial-apps/tree/master/flask-method-spoofing","className":"font-bold underline","children":"here on github"}],"."]}]]}],["$","footer",null,{"className":"mt-6","children":["$","$Lc",null,{"title":"Request Method Spoofing in Flask","postUrl":"/2020/07/06/request-method-spoofing-in-flask"}]}]]}]
